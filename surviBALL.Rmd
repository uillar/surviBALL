---
title: "surviBALL"
author: "Unai Illarregi Insausti"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```

## Prepare the environment

```{r Packages, message = FALSE, warning = FALSE}
suppressPackageStartupMessages(library(DESeq2))
suppressPackageStartupMessages(library(sva))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(limma))
library(ggplot2)
library(Rtsne)
suppressPackageStartupMessages(library(readr))
suppressPackageStartupMessages(library(lenght))
library(readxl)
suppressPackageStartupMessages(library(rstatix))
library(ggpubr)
suppressPackageStartupMessages(library(Hmisc))
library(survival)
suppressPackageStartupMessages(library(survminer))
suppressPackageStartupMessages(library(VennDiagram))
library(survivalROC)
suppressPackageStartupMessages(library(glmnet))
```

## Data upload & filtering for min. expression in each cohort

We will filter each cohort independently to take those lncRNAs minimally expressed in both cohorts. First we do it on C1 data:

```{r C1 prepare countData, message = FALSE, warning = FALSE}
countData_C1 = data.frame(read_delim("inputs/countData_C1.txt"), row.names = 1) #99695 x 50
Annotation_lncRNAKB <- read.delim("inputs/Annotation_lncRNAKB.txt")
lncRNAKB_annot <- data.frame(Annotation_lncRNAKB, row.names=1)
countData_C1 <- merge(countData_C1, lncRNAKB_annot, by=c(0))
countData_C1 = subset(countData_C1, !grepl("_", chr)) #From 99695 to 95776 genes
countData_C1 <- data.frame(countData_C1[, -c(52:57)], row.names = 1)
countData_C1 = countData_C1[rowSums(countData_C1 >= 1) >= 3,] #From 95776 to 94073 genes
```

We obtain as a result that 94073 genes are minimally expressed in C1 cohort. And now on C2 data:

```{r C2 prepare countData, message = FALSE, warning = FALSE}
countData_C2 = data.frame(read_delim("inputs/countData_C2.txt"), row.names = 1) #99695 x 72
countData_C2 <- merge(countData_C2, lncRNAKB_annot, by=c(0))
countData_C2 = subset(countData_C2, !grepl("_", chr)) #From 99695 to 95776 genes
countData_C2 <- data.frame(countData_C2[, -c(74:79)], row.names = 1)
countData_C2 = countData_C2[rowSums(countData_C2 >= 1) >= 3,] #From 95776 to 75886 genes
```

Here, the minimally expressed genes are much less, as we find 75886 genes with at least one count in three samples.

Now, we prepare the survival/clinical colData for each cohort. First for C1:

```{r C1 prepare colData, message = FALSE, warning = FALSE}
colData_C1 <- data.frame(read_delim("inputs/colData_C1.txt"), row.names = 1)
colData_C1$predictedSubtype <- as.factor(colData_C1$predictedSubtype)
colData_C1$eventTime <- as.factor(colData_C1$eventTime)
colData_C1$exitusTime <- as.factor(colData_C1$exitusTime)
print(identical(rownames(colData_C1),colnames(countData_C1)))
```

And now for C2:

```{r C2 prepare colData, message = FALSE, warning = FALSE}
colData_C2 <- data.frame(read_delim("inputs/colData_C2.txt"), row.names = 1)
colData_C2$predictedSubtype <- as.factor(colData_C2$predictedSubtype)
colData_C2$eventTime <- as.factor(colData_C2$eventTime)
colData_C2$exitusTime <- as.factor(colData_C2$exitusTime)
print(identical(rownames(colData_C2),colnames(countData_C2)))
```

## Overview of sample dispersion in t-SNE plots for each cohort and integrated

#C1

We correct the possible batch effect from different sequencing times in C1 cohort:

```{r comBat-seq C1, message = FALSE, warning = FALSE}
countData_C1 <- ComBat_seq(as.matrix(countData_C1), batch=colData_C1$seqBatch, group=colData_C1$EFS)
```

And we create the DESeq object with those adjusted counts:

```{r DESeq object C1, message = FALSE, warning = FALSE}
dds_C1 <- DESeqDataSetFromMatrix(countData = countData_C1, colData = colData_C1, design = ~EFS)
dds_C1 <- DESeq(dds_C1)
vst_C1 = vst(dds_C1)
norm_C1 = counts(dds_C1, normalized = T)
```

We apply now the sva correction:
 
```{r sva correction C1, message = FALSE, warning = FALSE}
mod_C1 <- model.matrix(~ predictedSubtype, colData(dds_C1))
mod0_C1 <- model.matrix(~ 1, colData(dds_C1))
svseq_C1 <- svaseq(norm_C1, mod_C1, mod0_C1)
ddssva_C1 <- dds_C1
i=svseq_C1[["n.sv"]]
ddssva_C1$SV <- svseq_C1$sv[,1:i]
tmpVST_C1=vst_C1
assay(tmpVST_C1)=removeBatchEffect(assay(tmpVST_C1), covariates=colData(ddssva_C1)$SV, design=model.matrix(~ predictedSubtype, colData(ddssva_C1)))
```

We see how the samples are represented in two dimensions with an MDS plot (t-SNE) with the sva correction:

```{r t-SNE plots C1, message = FALSE, warning = FALSE}
set.seed(12345)
nmbPCs = 10
perplexity = (nrow(colData_C1))^0.5
tsne_out <- Rtsne(t(assay(tmpVST_C1)),initial_dims=nmbPCs, perplexity=perplexity,max_iter=10000)
testData=data.frame(cbind(tsne_out$Y,as.character(colData_C1$EFS),as.character(colData_C1$cohort),as.character(rownames(colData_C1)),as.character(colData_C1$predictedSubtype),as.character(colData_C1$seqBatch)))
rownames(testData)=rownames(colData_C1)
colnames(testData)=c("tSNE1","tSNE2","EFS","cohort","name","subtype","batch")
testData$tSNE1=as.numeric(as.character(testData$tSNE1))
testData$tSNE2=as.numeric(as.character(testData$tSNE2))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=batch)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst_C1)), " lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=EFS)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst_C1)), " lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
```

# C2

Now we repeat the same for C2 cohort. In this case, the batch correction is done based on the read length for each sample. First group has less than 75 bp read, and the second one 101 bp reads.

```{r comBat-seq C2, message = FALSE, warning = FALSE}
countData_C2 <- ComBat_seq(as.matrix(countData_C2), batch=colData_C2$seqBatch, group=colData_C2$EFS)
```

We create the DESeq object for C2

```{r DESeq object C2, message = FALSE, warning = FALSE}
dds_C2 <- DESeqDataSetFromMatrix(countData = countData_C2, colData = colData_C2, design = ~EFS)
dds_C2 <- DESeq(dds_C2)
vst_C2 = vst(dds_C2)
norm_C2 = counts(dds_C2, normalized = T)
```

sva correction for C2:

```{r sva correction C2, message = FALSE, warning = FALSE}
mod_C2 <- model.matrix(~ predictedSubtype, colData(dds_C2))
mod0_C2 <- model.matrix(~ 1, colData(dds_C2))
svseq_C2 <- svaseq(norm_C2, mod_C2, mod0_C2)
ddssva_C2 <- dds_C2
i=svseq_C2[["n.sv"]]
ddssva_C2$SV <- svseq_C2$sv[,1:i]
tmpVST_C2=vst_C2
assay(tmpVST_C2)=removeBatchEffect(assay(tmpVST_C2), covariates=colData(ddssva_C2)$SV, design=model.matrix(~ predictedSubtype, colData(ddssva_C2)))
```

And t-SNE plot with sva correction for C2:

```{r t-SNE plots C2, message = FALSE, warning = FALSE}
set.seed(12345)
perplexity = (nrow(colData_C2))^0.5
tsne_out <- Rtsne(t(assay(tmpVST_C2)),initial_dims=nmbPCs, perplexity=perplexity,max_iter=10000)
testData=data.frame(cbind(tsne_out$Y,as.character(colData_C2$EFS),as.character(colData_C2$cohort),as.character(rownames(colData_C2)),as.character(colData_C2$predictedSubtype),as.character(colData_C2$seqBatch)))
rownames(testData)=rownames(colData_C2)
colnames(testData)=c("tSNE1","tSNE2","EFS","cohort","name","subtype","batch")
testData$tSNE1=as.numeric(as.character(testData$tSNE1))
testData$tSNE2=as.numeric(as.character(testData$tSNE2))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=batch)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst_C2)), " lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=EFS)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst_C2)), " lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
```

# Integrated

We now merge both cohorts:

```{r Integrate cohorts + comBat-seq, message = FALSE, warning = FALSE}
intersection <- intersect(rownames(countData_C1), rownames(countData_C2))
countData = cbind(countData_C1[intersection, ], countData_C2[intersection, ])
colData = rbind(colData_C1, colData_C2)
countData <- ComBat_seq(as.matrix(countData), batch=colData$cohort, group=colData$EFS)
print(identical(rownames(colData),colnames(countData)))
```

We create the integrated DESeq object:

```{r DESeq object, message = FALSE, warning = FALSE}
dds <- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~EFS)
dds <- DESeq(dds)
vst = vst(dds)
norm = counts(dds, normalized = T)
```

Apply the sva correction:

```{r sva correction, message = FALSE, warning = FALSE}
mod <- model.matrix(~ predictedSubtype, colData(dds))
mod0 <- model.matrix(~ 1, colData(dds))
svseq <- svaseq(norm, mod, mod0)
ddssva <- dds
i=svseq[["n.sv"]]
ddssva$SV <- svseq$sv[,1:i]
tmpVST=vst
assay(tmpVST)=removeBatchEffect(assay(tmpVST), covariates=colData(ddssva)$SV, design=model.matrix(~ predictedSubtype, colData(ddssva)))
```

And do the t-SNE plots:

```{r t-SNE plots, message = FALSE, warning = FALSE}
set.seed(12345)
perplexity = (nrow(colData))^0.5
tsne_out <- Rtsne(t(assay(tmpVST)),initial_dims=nmbPCs, perplexity=perplexity,max_iter=10000)
testData=data.frame(cbind(tsne_out$Y,as.character(colData$EFS),as.character(colData$cohort),as.character(rownames(colData)),as.character(colData$predictedSubtype)))
rownames(testData)=rownames(colData)
colnames(testData)=c("tSNE1","tSNE2","EFS","cohort","name","subtype")
testData$tSNE1=as.numeric(as.character(testData$tSNE1))
testData$tSNE2=as.numeric(as.character(testData$tSNE2))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=cohort)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst)), " PC + lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
ggplot(testData, aes(tSNE1, tSNE2, color=subtype, shape=EFS)) + geom_point(size=3) + xlab("tSNE1") + ylab("tSNE2") + theme_test() + theme(plot.title = element_text(size=12)) + ggtitle(paste("t-SNE with ", nrow(assay(vst)), " PC + lncRNAs\n", "Perplexity: ", round(perplexity, 3), sep = "")) + scale_shape_manual(values=c(19, 17))
```

#Global expression comprison

Now we see if we see differences in global expression between cohorts:

```{r Global expression integrated cohort, message = FALSE, warning = FALSE}
globalExpr = data.frame(apply(norm,2,sum))
globalExpr=log2(globalExpr)
colnames(globalExpr)[1]="global_expression"
m=merge(colData,globalExpr,by='row.names')
legend_title <- "cohort"
stats <- m %>%
t_test(data =., global_expression ~ cohort) %>%
adjust_pvalue(method = "bonferroni") %>%
add_significance("p.adj") %>%
add_xy_position(x = "cohort")
ggplot(m, aes(x = cohort, y = global_expression)) +
geom_boxplot(aes(fill=as.factor(cohort))) +
theme_bw() +
ylab("Global expression") +
xlab("Cohort") +
ggtitle("Boxplot with global expression per cohort") +
scale_fill_manual(values = c("#9857A4", "#53A054"), name = "cohort") +
stat_pvalue_manual(stats, label = "p.adj.signif", tip.length = 0.01)  
```

```{r Global expression integrated relapse, message = FALSE, warning = FALSE}
globalExpr = data.frame(apply(norm,2,sum))
globalExpr=log2(globalExpr)
colnames(globalExpr)[1]="global_expression"
m=merge(colData,globalExpr,by='row.names')
legend_title <- "EFS"
stats <- m %>%
t_test(data =., global_expression ~ EFS) %>%
adjust_pvalue(method = "bonferroni") %>%
add_significance("p.adj") %>%
add_xy_position(x = "EFS")
ggplot(m, aes(x = EFS, y = global_expression)) +
geom_boxplot(aes(fill=as.factor(EFS))) +
theme_bw() +
ylab("Global expression") +
xlab("EFS") +
ggtitle("Boxplot with global expression per EFS") +
scale_fill_manual(values = c("#4889A4", "#C26060"), name = "EFS") +
stat_pvalue_manual(stats, label = "p.adj.signif", tip.length = 0.01)  
```

## Survival analyses

# Univariate Cox (CoxUV) for gene selection

```{r CoxUV C1, message = FALSE, warning = FALSE}
Bizi_num_C1 = t(norm_C1[rownames(countData_C1),])
Bizi_num_C1 = data.frame(merge(colData_C1, Bizi_num_C1, by = c(0)))
Bizi_num_C1$eventTime = as.numeric(as.character(Bizi_num_C1$eventTime))
Bizi_num_C1$EFSb[Bizi_num_C1$EFS == "relapse"] <- "1"
Bizi_num_C1$EFSb[Bizi_num_C1$EFS == "noRelapse"] <- "0"
Bizi_num_C1$EFSb = as.numeric(as.character(Bizi_num_C1$EFSb))
genes <- c(rownames(countData_C1))
CoxUV_C1 <- data.frame(gene = character(), beta = numeric(), HR = numeric(), wald.test = numeric(), p.value = numeric(), concordance = numeric(), stringsAsFactors = FALSE)
for (i in genes) {
  a <- coxph(Surv(eventTime, EFSb) ~ Bizi_num_C1[[i]], data = Bizi_num_C1, control = coxph.control(iter.max = 5))
  x <- summary(a)
  p.value <- signif(x$wald["pvalue"], digits=2)
  wald.test <- signif(x$wald["test"], digits=2)
  beta <- signif(x$coef[1], digits=2)
  HR <- signif(x$coef[2], digits=2)
  concordance <- a[["concordance"]][["concordance"]]
  CoxUV_C1[i, ] <- c(gene = i, beta = beta, HR = HR, wald.test = wald.test, p.value = p.value, concordance = concordance)}
CoxUV_C1$p.value = as.numeric(CoxUV_C1$p.value)
CoxUV_C1$HR = as.numeric(CoxUV_C1$HR)
CoxUV_C1_sig_high = subset(CoxUV_C1, CoxUV_C1$p.value < .01 & CoxUV_C1$HR > 1)
nrow(CoxUV_C1_sig_high)
CoxUV_C1_sig_low = subset(CoxUV_C1, CoxUV_C1$p.value < .01 & CoxUV_C1$HR < 1)
nrow(CoxUV_C1_sig_low)
```

```{r CoxUV C2, message = FALSE, warning = FALSE}
Bizi_num_C2 = t(norm_C2[rownames(countData_C2),])
Bizi_num_C2 = data.frame(merge(colData_C2, Bizi_num_C2, by = c(0)))
Bizi_num_C2$eventTime = as.numeric(as.character(Bizi_num_C2$eventTime))
Bizi_num_C2$EFSb[Bizi_num_C2$EFS == "relapse"] <- "1"
Bizi_num_C2$EFSb[Bizi_num_C2$EFS == "noRelapse"] <- "0"
Bizi_num_C2$EFSb = as.numeric(as.character(Bizi_num_C2$EFSb))
genes <- c(rownames(countData_C2))
CoxUV_C2 <- data.frame(gene = character(), beta = numeric(), HR = numeric(), wald.test = numeric(), p.value = numeric(), concordance = numeric(), stringsAsFactors = FALSE)
for (i in genes) {
  a <- coxph(Surv(eventTime, EFSb) ~ Bizi_num_C2[[i]], data = Bizi_num_C2, control = coxph.control(iter.max = 5))
  x <- summary(a)
  p.value <- signif(x$wald["pvalue"], digits=2)
  wald.test <- signif(x$wald["test"], digits=2)
  beta <- signif(x$coef[1], digits=2)
  HR <- signif(x$coef[2], digits=2)
  concordance <- a[["concordance"]][["concordance"]]
  CoxUV_C2[i, ] <- c(gene = i, beta = beta, HR = HR, wald.test = wald.test, p.value = p.value, concordance = concordance)}
CoxUV_C2$p.value = as.numeric(CoxUV_C2$p.value)
CoxUV_C2$HR = as.numeric(CoxUV_C2$HR)
CoxUV_C2_sig_high = subset(CoxUV_C2, CoxUV_C2$p.value < .01 & CoxUV_C2$HR > 1)
nrow(CoxUV_C2_sig_high)
CoxUV_C2_sig_low = subset(CoxUV_C2, CoxUV_C2$p.value < .01 & CoxUV_C2$HR < 1)
nrow(CoxUV_C2_sig_low)
```

# CoxUV results extraction

```{r Extract CoxUV overlap results, message = FALSE, warning = FALSE}
CoxUV_C1_sig = rbind(CoxUV_C1_sig_high, CoxUV_C1_sig_low)
CoxUV_C1_sig = data.frame(merge(CoxUV_C1_sig[, -c(1)], lncRNAKB_annot, by = c(0)), row.names = 1)
CoxUV_C2_sig = rbind(CoxUV_C2_sig_high, CoxUV_C2_sig_low)
CoxUV_C2_sig = data.frame(merge(CoxUV_C2_sig[, -c(1)], lncRNAKB_annot, by = c(0)), row.names = 1)
write.table(CoxUV_C1_sig, "results/CoxUV_C1_sig.txt", sep = "\t")
write.table(CoxUV_C2_sig, "results/CoxUV_C2_sig.txt", sep = "\t")
```

# CoxUV overlap selection

```{r Get CoxUV overlap + Venn diagram, message = FALSE, warning = FALSE}
overlap_CoxUV_high = intersect(rownames(CoxUV_C1_sig_high), rownames(CoxUV_C2_sig_high))
lenght(overlap_CoxUV_high)
overlap_CoxUV_low = intersect(rownames(CoxUV_C1_sig_low), rownames(CoxUV_C2_sig_low))
lenght(overlap_CoxUV_low)
CoxUV_overlap = overlap_CoxUV_high
lenght(CoxUV_overlap)
Venn_input <- list(rownames(CoxUV_C1_sig_high), rownames(CoxUV_C1_sig_low), rownames(CoxUV_C2_sig_high), rownames(CoxUV_C2_sig_low))
display_venn <- function(x, ...){
  grid.newpage()
  venn_object <- venn.diagram(x, filename = NULL, ...)
  grid.draw(venn_object)}
display_venn(
  Venn_input,
  category.names = c("CoxUV_C1_high" , "CoxUV_C1_low", "CoxUV_C2_high", "CoxUV_C2_low"),
  fill = c("mediumorchid", "sienna1", "salmon", "pink"),
  lwd = 2,
  lty = 'blank',
  cat.fontface = "bold")
Venn_input <- list(rownames(CoxUV_C1_sig_high), rownames(CoxUV_C2_sig_high))
display_venn <- function(x, ...){
  grid.newpage()
  venn_object <- venn.diagram(x, filename = NULL, ...)
  grid.draw(venn_object)}
display_venn(
  Venn_input,
  category.names = c("CoxUV_C1_sig" , "CoxUV_C2_sig"),
  fill = c("mediumorchid", "salmon"),
  lwd = 2,
  lty = 'blank',
  cat.fontface = "bold")
```

# ALASSO (https://rpubs.com/kaz_yos/alasso) variables selection + model development

```{r ALASSO C1 variable selection, message = FALSE, warning = FALSE}
set.seed(12345)
norm_C1_CoxUV = data.frame(norm_C1[CoxUV_overlap, ])
colData_C1_surv = colData_C1
colData_C1_surv$EFSb[colData_C1_surv$EFS == "relapse"] <- "1"
colData_C1_surv$EFSb[colData_C1_surv$EFS == "noRelapse"] <- "0"
colData_C1_surv$EFSb = as.numeric(as.character(colData_C1_surv$EFSb))
colData_C1_surv$eventTime = as.numeric(as.character(colData_C1_surv$eventTime))
norm_C1_CoxUV = cbind(colData_C1_surv, t(norm_C1_CoxUV))
x = as.matrix(data.frame(norm_C1_CoxUV[, -c(2:14)], row.names = 1))
eventTime = norm_C1_CoxUV$eventTime
EFS = norm_C1_CoxUV$EFSb
y = Surv(eventTime, EFS)
ridge_cv <- cv.glmnet(x = x, y = y, type.measure = "C", nfold = 10, family = "cox", alpha = 0)
best_ridge_coef <- coef(ridge_cv, s = ridge_cv$lambda.min)
C1_CoxUV_ALASSO_cv <- cv.glmnet(x = x, y = y, type.measure = "C", nfold = 10, family = "cox", alpha = 1, penalty.factor = 1 / abs(best_ridge_coef), keep = T)
print(C1_CoxUV_ALASSO_cv)
plot(C1_CoxUV_ALASSO_cv)
coef(C1_CoxUV_ALASSO_cv, s = C1_CoxUV_ALASSO_cv$lambda.min)
```

```{r ALASSO C1 model development, message = FALSE, warning = FALSE}
cox_C1_CoxUV_ALASSO_vars = c("lnckb.32044", "lnckb.61426", "lnckb.66409", "lnckb.83321", "lnckb.8576")
surviBALL = coxph(Surv(eventTime, EFSb) ~ lnckb.32044 + lnckb.61426 + lnckb.66409 + lnckb.83321 + lnckb.8576, data = norm_C1_CoxUV, x = T)
summary(surviBALL)
round(cox.zph(surviBALL)$table, 2)
ggforest(surviBALL)

#UV C1
surviBALL_32044 = coxph(Surv(eventTime, EFSb) ~ lnckb.32044, data = Bizi_num_C1, x = T)
summary(surviBALL_32044)
surviBALL_61426 = coxph(Surv(eventTime, EFSb) ~ lnckb.61426, data = Bizi_num_C1, x = T)
summary(surviBALL_61426)
surviBALL_66409 = coxph(Surv(eventTime, EFSb) ~ lnckb.66409, data = Bizi_num_C1, x = T)
summary(surviBALL_66409)
surviBALL_83321 = coxph(Surv(eventTime, EFSb) ~ lnckb.83321, data = Bizi_num_C1, x = T)
summary(surviBALL_83321)
surviBALL_8576 = coxph(Surv(eventTime, EFSb) ~ lnckb.8576, data = Bizi_num_C1, x = T)
summary(surviBALL_8576)

#UV C2
surviBALL_32044_C2 = coxph(Surv(eventTime, EFSb) ~ lnckb.32044, data = Bizi_num_C2, x = T)
summary(surviBALL_32044_C2)
surviBALL_61426_C2 = coxph(Surv(eventTime, EFSb) ~ lnckb.61426, data = Bizi_num_C2, x = T)
summary(surviBALL_61426_C2)
surviBALL_66409_C2 = coxph(Surv(eventTime, EFSb) ~ lnckb.66409, data = Bizi_num_C2, x = T)
summary(surviBALL_66409_C2)
surviBALL_83321_C2 = coxph(Surv(eventTime, EFSb) ~ lnckb.83321, data = Bizi_num_C2, x = T)
summary(surviBALL_83321_C2)
surviBALL_8576_C2 = coxph(Surv(eventTime, EFSb) ~ lnckb.8576, data = Bizi_num_C2, x = T)
summary(surviBALL_8576_C2)

#saveRDS(surviBALL, file = "surviBALL.rda")
```

```{r DESeq object C2, message = FALSE, warning = FALSE}
# Redo dds object with just intercept (~1)

#C1
dds1_C1 <- DESeqDataSetFromMatrix(countData = countData_C1, colData = colData_C1, design = ~ 1)
dds1_C1 <- DESeq(dds1_C1)
vst1_C1 = vst(dds1_C1)
norm1_C1 = counts(dds1_C1, normalized = T)
write.table(norm1_C1, "results/norm1_C1.txt", sep = "\t")

#C2
dds1_C2 <- DESeqDataSetFromMatrix(countData = countData_C2, colData = colData_C2, design = ~ 1)
dds1_C2 <- DESeq(dds1_C2)
vst1_C2 = vst(dds1_C2)
norm1_C2 = counts(dds1_C2, normalized = T)
write.table(norm1_C2, "results/norm1_C2.txt", sep = "\t")

#C1 + C2
dds1 <- DESeqDataSetFromMatrix(countData = countData, colData = colData, design = ~ 1)
dds1 <- DESeq(dds1)
vst1 = vst(dds1)
norm1 = counts(dds1, normalized = T)
write.table(norm1, "results/norm1.txt", sep = "\t")
```

#McLernon statistics

```{r C1 McLernon Discrimination, message = FALSE, warning = FALSE}
# Prepare C1 data
norm_C1_CoxUV = data.frame(norm1_C1[CoxUV_overlap, ])
colData_C1_surv = colData_C1
colData_C1_surv$EFSb[colData_C1_surv$EFS == "relapse"] <- "1"
colData_C1_surv$EFSb[colData_C1_surv$EFS == "noRelapse"] <- "0"
colData_C1_surv$EFSb = as.numeric(as.character(colData_C1_surv$EFSb))
colData_C1_surv$eventTime = as.numeric(as.character(colData_C1_surv$eventTime))
norm_C1_CoxUV_ROC = cbind(colData_C1_surv, t(norm_C1_CoxUV))

# Time-dependent ROC C1
norm_C1_CoxUV_ROC$lpALASSO <- predict(surviBALL, newdata = norm_C1_CoxUV_ROC, type = "lp")
nobs <- NROW(norm_C1_CoxUV_ROC)
timeCut <- 60
Staltscore4 <- NULL
ROC_C1 <- survivalROC.C(Stime = norm_C1_CoxUV_ROC$eventTime,
                            status = norm_C1_CoxUV_ROC$EFSb,
                            marker = norm_C1_CoxUV_ROC$lpALASSO,
                            predict.time = timeCut,
                            span = 0.25*nobs^(-0.20))
plot(ROC_C1$FP, ROC_C1$TP, type = "l",
     xlim = c(0,1), ylim = c(0,1),
     xlab = paste( "FP \n AUC =", round(ROC_C1$AUC,3)),
     ylab = "TP", main = "Time-dependent five-year \nROC curve surviBALL")
abline(0,1)

# Uno's C C1
(Uno_C_C1 <- concordance(Surv(eventTime, EFSb) ~ lpALASSO, 
                           norm_C1_CoxUV_ROC, 
                           reverse = T,
                           timewt = "n/G2"))
```


```{r C1 McLernon Calibration, message = FALSE, warning = FALSE}
pacman::p_load(survival, Hmisc, rms)
norm_C1_CoxUV_ROC$predALASSO <- riskRegression::predictRisk(surviBALL,
                                          newdata = norm_C1_CoxUV_ROC,
                                          times = 60)
norm_C1_CoxUV_ROC$predALASSO.cll <- log(-log(1 - norm_C1_CoxUV_ROC$predALASSO))

# Estimate actual risk
vcal <- rms::cph(Surv(eventTime, EFSb) ~ rcs(predALASSO.cll, 3),
                 x = T,
                 y = T,
                 surv = T,
                 data = norm_C1_CoxUV_ROC) 
dat_cal <- cbind.data.frame(
  "obs" = 1 - rms::survest(vcal,
                           times = 60,
                           newdata = norm_C1_CoxUV_ROC)$surv,
  "pred" = norm_C1_CoxUV_ROC$predALASSO)

# Calculate observed and predicted event probabilities
observed_probs <- 1 - rms::survest(vcal, times = 60, newdata = norm_C1_CoxUV_ROC)$surv
predicted_probs <- norm_C1_CoxUV_ROC$predALASSO

# Create a data frame for calibration
dat_cal <- data.frame(
  "observed" = observed_probs,
  "predicted" = predicted_probs)

# ICI with bootstrap for CI calculation
set.seed(123)
n_bootstrap <- 100

# Function
calc_ici <- function(data) {
  absdiff <- abs(data$pred - data$obs)
  mean(absdiff)  # ICI es el promedio de las diferencias absolutas
}

bootstrap_results <- replicate(n_bootstrap, {
  # Muestra aleatoria con reemplazo
  sample_data <- dat_cal[sample(1:nrow(dat_cal), replace = T), ]
  calc_ici(sample_data)
})

# ICI
ici <- calc_ici(dat_cal)
ci_95 <- quantile(bootstrap_results, c(0.025, 0.975))

# Mostrar resultados
(nums_cph <- c(
  "ICI" = ici,
  "CI_95_Lower" = ci_95[1],
  "CI_95_Upper" = ci_95[2]))
```

# Brier score

```{r, Brier, fig.align='center',warning=FALSE,message=FALSE, echo=TRUE, eval=FALSE, fig.width=6, fig.height=6}
#Two overall performance measures are proposed for prediction models with a survival outcome:
  
#  + Brier score: it is the mean squared difference between observed event indicators and predicted risks at a fixed time point (e.g. at 5 years), lower is better;

#  + Scaled Brier score, also known as Index of Prediction Accuracy (IPA): it improves interpretability by scaling the Brier Score. It is the decrease in Brier compared to a null model, expressed as a percentage, higher is better. 

# Overall performance: Brier and scaled Brier (IPA) scores
set.seed(1)
score_C1 <-
  riskRegression::Score(list("surviBALL" = surviBALL),
                        formula = Surv(eventTime, EFSb) ~ 1, 
                        data = norm_C1_CoxUV_ROC, 
                        conf.int = T, 
                        times = timeCut,
                        cens.model = "km", 
                        metrics = "brier",
                        summary = "ipa")
score_C1[["Brier"]][["score"]]


# Extra: bootstrap confidence intervals for IPA ------
B <- 10
horizon <- 60
boots_ls <- lapply(seq_len(B), function(b) {
  # Resample validation data
  data_boot <- norm_C1_CoxUV_ROC[sample(nrow(norm_C1_CoxUV_ROC), replace = T), ]
  # Get IPA on boot validation data
  score_boot <- riskRegression::Score(
    list("cox_validation" = surviBALL),
    formula = Surv(eventTime, EFSb) ~ 1,
    cens.model = "km", 
    data = data_boot, 
    conf.int = F, 
    times = horizon,
    metrics = c("brier"),
    summary = c("ipa"))
  #.. C1 add other measure heres, eg. concordance
  ipa_boot <- score_boot$Brier$score[model == "cox_validation"][["IPA"]]
  cbind.data.frame("ipa" = ipa_boot)
})
df_boots_C1 <- do.call(rbind.data.frame, boots_ls)
# Table overall measures
alpha <- .05
temp <- c(
  score_C1$Brier$score[model == "surviBALL"][["Brier"]],
  score_C1$Brier$score[model == "surviBALL"][["lower"]],
  score_C1$Brier$score[model == "surviBALL"][["upper"]],
  score_C1$Brier$score[model == "surviBALL"][["IPA"]], 
  quantile(df_boots_C1$ipa, probs = alpha / 2),
  quantile(df_boots_C1$ipa, probs = 1 - alpha / 2))
res_C  <- matrix(temp, 
                nrow = 2, 
                ncol = 3, 
                byrow = TRUE,
                dimnames = list(
  c("Brier - C1 cohort", 
    "Scaled Brier - C1 cohort"),
  c("Estimate", "Lower .95", "Upper .95")))
res_C <- round(res_C, 3)
res_C
```

# bootstrap_cv

```{r RISK-SCORE calculation in SJALL cohort, message = FALSE, warning = FALSE}
if (!require("pacman")) install.packages("pacman")
library(pacman)

pacman::p_load(
  rio,
  survival,
  rms,
  pec,
  tidyverse,
  timeROC,
  riskRegression
)


bootstrap_cv <- function(db, B,
                         time,
                         status,
                         formula_model,
                         pred.time,
                         formula_ipcw,
                         seed = 1) {
  frm_model <- as.formula(formula_model)
  frm_ipcw <- as.formula(formula_ipcw)
  db$id <- 1:nrow(db)


  # Duplicate data
  db_ext <- db %>% dplyr::slice(rep(dplyr::row_number(), B))
  db_ext$.rep <- with(db_ext, ave(seq_along(id), id, FUN = seq_along)) # add an index identifying the replications

  db_tbl <- db_ext %>%
    dplyr::group_by(.rep) %>%
    tidyr::nest() %>%
    dplyr::rename(
      orig_data = data,
      id_boot = .rep
    )

  # Create bootstrap samples
  sample_boot <- function(db, B) {
    set.seed(seed)
    db_boot <- matrix(NA, nrow = nrow(db) * B, ncol = ncol(db))
    sample_row <- list()
    for (j in 1:B) {
      sample_row[[j]] <- sample(nrow(db), size = nrow(db), replace = TRUE)
    }
    sample_row <- unlist(sample_row)
    db_boot <- db[sample_row, ]
    db_boot$id_boot <- sort(rep(1:B, nrow(db)))
    db_boot <- db_boot %>%
      dplyr::group_by(id_boot) %>%
      tidyr::nest() %>%
      dplyr::rename(boot_data = data)
    return(db_boot)
  }

  # Join original data and the bootstrap data in a nested tibble
  a <- sample_boot(db, B)
  b <- a %>% left_join(db_tbl)

  # Create optimism-corrected performance measures
  b <- b %>% 
    dplyr::mutate(
      cox_boot = purrr::map(
      boot_data,
      ~ coxph(frm_model, data = ., x = T, y = T)
    ),
    
    cox_apparent = purrr::map(
      orig_data,
      ~ coxph(frm_model, data = ., x = T, y = T)
    ),
    
    # Discrimination assessment ------ 
    # Discrimination - time range (Harrell & Uno c-statistic)
    
    Harrell_C_app =
      purrr::map2_dbl(
      orig_data, cox_apparent,
      ~ survival::concordance(Surv(.x[[time]], .x[[status]])
                              ~ predict(.y, newdata = .x),
                              reverse = TRUE)$concordance
    ),
    
    Harrell_C_orig =
      purrr::map2_dbl(
        orig_data, cox_boot,
        ~ survival::concordance(Surv(.x[[time]], .x[[status]]) 
                                ~ predict(.y, newdata = .x),
                                reverse = TRUE)$concordance
      ),
    
    Harrell_C_boot =
      purrr::map2_dbl(
        boot_data, cox_boot,
        ~ survival::concordance(Surv(.x[[time]],.x[[status]])
                                ~ predict(.y, newdata = .x),
                                reverse = TRUE)$concordance
      ),
    
    Harrell_C_diff = 
      purrr::map2_dbl(
        Harrell_C_boot, Harrell_C_orig,
        function(a, b) {
          a - b
      }
    ),
    
    Uno_C_app =
      purrr::map2_dbl(
        orig_data, cox_apparent,
        ~ survival::concordance(Surv(.x[[time]], .x[[status]])
                                ~ predict(.y, newdata = .x),
                                reverse = TRUE,
                                timewt = "n/G2")$concordance
      ),
    
    Uno_C_orig =
      purrr::map2_dbl(
        orig_data, cox_boot,
        ~ survival::concordance(Surv(.x[[time]], .x[[status]])
                                ~ predict(.y, newdata = .x),
                                reverse = TRUE,
                                timewt = "n/G2")$concordance
      ),
    
    Uno_C_boot =
      purrr::map2_dbl(
        boot_data, cox_boot,
        ~ survival::concordance(Surv(.x[[time]],.x[[status]])
                                ~ predict(.y, newdata = .x),
                                reverse = TRUE,
                                timewt = "n/G2")$concordance
      ),
    
    Uno_C_diff = 
      purrr::map2_dbl(
        Uno_C_boot, Uno_C_orig,
        function(a, b) {
          a - b
      }
    ),
    
    # Discrimination - fixed time horizon (Uno's AUC)
    
    AUC_app = map2_dbl(
      orig_data, cox_apparent,
      ~ timeROC::timeROC(
        T = .x[[time]], delta = .x[[status]],
        marker = predict(.y, newdata = .x),
        cause = 1, weighting = "marginal", times = pred.time,
        iid = FALSE
      )$AUC[[2]]
    ),
    
    AUC_orig = map2_dbl(
      orig_data, cox_boot,
      ~ timeROC::timeROC(
        T = .x[[time]], delta = .x[[status]],
        marker = predict(.y, newdata = .x),
        cause = 1, weighting = "marginal", times = pred.time,
        iid = FALSE
      )$AUC[[2]]
    ),
    
    AUC_boot = purrr::map2_dbl(
      boot_data, cox_boot,
      ~ timeROC::timeROC(
        T = .x[[time]], delta = .x[[status]],
        marker = predict(.y, newdata = .x),
        cause = 1, weighting = "marginal", times = pred.time,
        iid = FALSE
      )$AUC[[2]]
    ),
    
    AUC_diff = purrr::map2_dbl(
      AUC_boot, AUC_orig,
      function(a, b) {
        a - b
      }
    ),
    
    # Overall performance - Brier Score & Scaled Brier 
    Score_app = purrr::map2(
      orig_data, cox_apparent,
      ~ riskRegression::Score(list("Cox" = .y),
                              formula = frm_ipcw,
                              data = .x, times = pred.time,
                              cens.model = "km",
                              metrics = "brier",
                              summary = "ipa"
                              )$Brier[[1]]
    ),
    
    Brier_app = purrr::map_dbl(Score_app, ~ .x$Brier[[2]]),
    IPA_app = purrr::map_dbl(Score_app, ~ .x$IPA[[2]]),
    Score_orig = purrr::map2(
      orig_data, cox_boot,
      ~ riskRegression::Score(list("Cox" = .y),
                              formula = frm_ipcw,
                              data = .x, times = pred.time,
                              cens.model = "km",
                              metrics = "brier",
                              summary = "ipa"
                              )$Brier[[1]]
    ),
    
    Brier_orig = purrr::map_dbl(Score_orig, ~ .x$Brier[[2]]),
    IPA_orig = purrr::map_dbl(Score_orig, ~ .x$IPA[[2]]),
    Score_boot = purrr::map2(
      boot_data, cox_boot,
      ~ riskRegression::Score(list("Cox" = .y),
                              formula = frm_ipcw,
                              data = .x, times = pred.time,
                              cens.model = "km",
                              metrics = "brier",
                              summary = "ipa"
                              )$Brier[[1]]
    ),
    
    Brier_boot = purrr::map_dbl(Score_boot, ~ .x$Brier[[2]]),
    IPA_boot = purrr::map_dbl(Score_boot, ~ .x$IPA[[2]]),
    Brier_diff = purrr::map2_dbl(
      Brier_boot, Brier_orig,
      function(a, b) {
        a - b
      }
    ),
    
    IPA_diff = purrr::map2_dbl(
      IPA_boot, IPA_orig,
      function(a, b) {
        a - b
      }
    ),
    
    
  # Calibration assessment --------
  
  obs_apparent = purrr::map_dbl(orig_data, ~ 
                                  summary(survival::survfit(Surv(.x[[time]], .x[[status]]) ~ 1,
                                                            data = .), time = pred.time)$surv), 
  # obs_apparent and obs_orig should be the same in this case
  obs_boot = purrr::map_dbl(boot_data, ~ 
                              summary(survival::survfit(Surv(.x[[time]], .x[[status]]) ~ 1,
                                                        data = .), time = pred.time)$surv),
  
  pred_apparent = purrr::map2(orig_data, 
                              cox_apparent, 
                              ~ riskRegression::predictRisk(.y,
                                                            newdata = .x,
                                                            time = pred.time)),
  
  pred_orig = purrr::map2(orig_data, 
                          cox_boot, 
                          ~ riskRegression::predictRisk(.y,
                                                        newdata = .x,
                                                        time = pred.time)),
  
  pred_boot = purrr::map2(boot_data, 
                          cox_boot, 
                          ~ riskRegression::predictRisk(.y,
                                                        newdata = .x,
                                                        time = pred.time)),
  
  OE_apparent = purrr::map2_dbl(obs_apparent, 
                                pred_apparent, 
                                ~ (1 - .x) / mean(.y)),
  
  OE_orig = purrr::map2_dbl(obs_apparent, 
                            pred_orig, 
                            ~ (1 - .x) / mean(.y)),
  
  OE_boot = purrr::map2_dbl(obs_boot, 
                            pred_boot, 
                            ~ (1 - .x) / mean(.y)),
  
  OE_diff = purrr::map2_dbl(OE_boot, OE_orig, 
                            function(a, b) {
                              a - b
                            }
  ),
  
  
  # mean calibration - time range assessment
  
  p_apparent = purrr::map2(orig_data, 
                           cox_apparent,
                           ~ predict(.y,
                                     newdata = .x,
                                     type = "expected")),
  
  p_orig = purrr::map2(orig_data, 
                       cox_boot,
                       ~ predict(.y,
                                 newdata = .x,
                                 type = "expected")),
  
  p_boot = purrr::map2(boot_data, 
                       cox_boot,
                       ~ predict(.y,
                                 newdata = .x,
                                 type = "expected")),
  
  intercept_app = purrr::map2_dbl(orig_data, 
                                  p_apparent,
                                  ~ exp(glm(.x[[status]] ~ offset(log(.y)), 
                                            family = poisson,
                                            data = .x,
                                            subset = (.y > 0))$coefficients)),
  
  
  intercept_orig = purrr::map2_dbl(orig_data, 
                                   p_orig,
                                   ~ exp(glm(.x[[status]] ~ offset(log(.y)), 
                                             family = poisson,
                                             data = .x,
                                             subset = (.y > 0))$coefficients)),
  
  intercept_boot = purrr::map2_dbl(boot_data, 
                                   p_boot,
                                   ~ exp(glm(.x[[status]] ~ offset(log(.y)), 
                                             family = poisson,
                                             data = .x,
                                             subset = (.y > 0))$coefficients)),
  
  
  intercept_diff = purrr::map2_dbl(intercept_boot, 
                                   intercept_orig,
                                   function(a, b) {
                                     a - b
                                   }),
  
  
  # weak calibration - fixed t
  
  lp_apparent = purrr::map2(orig_data, 
                            cox_apparent,
                            ~ predict(.y, newdata = .x, type = "lp")),
  
  lp_orig = purrr::map2(orig_data, 
                        cox_boot,
                        ~ predict(.y, newdata = .x, type = "lp")),
  
  lp_boot = purrr::map2(boot_data, 
                        cox_boot,
                        ~ predict(.y, newdata = .x, type = "lp")),
  
  
  slope_apparent = purrr::map2_dbl(orig_data, 
                                   lp_apparent,
                                   ~ coxph(Surv(.x[[time]], .x[[status]]) ~ .y)$coefficients), 
  
  slope_orig =purrr:: map2_dbl(orig_data, 
                               lp_orig,
                               ~ coxph(Surv(.x[[time]], .x[[status]]) ~ .y)$coefficients),
  
  slope_boot = purrr::map2_dbl(boot_data, 
                               lp_boot,
                               ~ coxph(Surv(.x[[time]], .x[[status]]) ~ .y)$coefficients),
  
  slope_diff = purrr::map2_dbl(slope_boot, 
                               slope_orig,
                               function(a, b) {
                                 a - b
                               }),
  
  # weak calibration - time range
  slope_range_apparent = purrr::pmap_dbl(list(lp = lp_apparent,
                                              p = p_apparent,
                                              db = orig_data),
                                         function(lp, p, db){
                                           slope = glm(db[[status]] ~ lp + offset(log(p) - lp), 
                                                       data = as.data.frame(db),
                                                       family = poisson,
                                                       subset = (p > 0))$coefficients[2]
                                         }),
  
  slope_range_orig = purrr::pmap_dbl(list(lp = lp_orig,
                                          p = p_orig,
                                          db = orig_data),
                                     function(lp, p, db){
                                       slope = glm(db[[status]] ~  lp + offset(log(p) - lp), 
                                                   data = as.data.frame(db),
                                                   family = poisson,
                                                   subset = (p > 0))$coefficients[2]
                                     }),
  
  slope_range_boot = purrr::pmap_dbl(list(lp = lp_boot, 
                                          p = p_boot, 
                                          db = boot_data),
                                     function(lp, p, db){
                                       slope = glm(db[[status]] ~  lp + offset(log(p) - lp), 
                                                   data = as.data.frame(db),
                                                   family = poisson,
                                                   subset = (p > 0))$coefficients[2]
                                     }),
  
  slope_range_diff =purrr::map2_dbl(slope_range_boot, slope_range_orig,
                                    function(a, b){
                                      a - b
                                    })
  
  
  )
  
  # Generate output
  # Discrimation & overall performance (Brier) ---
  AUC_corrected <- b$AUC_app[1] - mean(b$AUC_diff)
  Brier_corrected <- b$Brier_app[1] - mean(b$Brier_diff)
  IPA_corrected <- b$IPA_app[1] - mean(b$IPA_diff)
  Harrell_C_corrected <- b$Harrell_C_app[1] - mean(b$Harrell_C_diff)
  
  # Calibration ---
  OE_corrected <- b$OE_apparent[1] - mean(b$OE_diff)
  intercept_corrected <- b$intercept_app[1] - mean(b$intercept_diff)
  slope_corrected <- b$slope_apparent[1] - mean(b$slope_diff)
  slope_range_corrected <- b$slope_range_apparent[1] - mean(b$slope_range_diff)
  
  Uno_C_corrected <- b$Uno_C_app[1] - mean(b$Uno_C_diff)
  res <- c("Brier corrected" = Brier_corrected, 
           "IPA corrected" = IPA_corrected
           )
  return(cbind(res))
}
```

```{r C1 McLernon Calibration, message = FALSE, warning = FALSE}
(int_val_C1 <- bootstrap_cv(db = norm_C1_CoxUV_ROC, B = 30,
                        seed = 1,
                        time = "eventTime",
                        status = "EFSb",
                        formula_model = "Surv(eventTime, EFSb) ~ lnckb.32044 + lnckb.61426 + lnckb.66409 + lnckb.83321 + lnckb.8576",
                        formula_ipcw = "Surv(eventTime, EFSb) ~ 1",
                        pred.time = 60))
```

## Risk KM plots

```{r RISK-SCORE calculation in C1 ALASSO, message = FALSE, warning = FALSE}
norm_C1_CoxUV = data.frame(norm1_C1)
colData_C1_surv = colData_C1
colData_C1_surv$eventTime = as.numeric(as.character(colData_C1_surv$eventTime))
norm_C1_CoxUV = cbind(colData_C1_surv, t(norm_C1_CoxUV))
#Predictions
norm_C1_CoxUV$predRisk = predict(surviBALL)
#Risk plot
norm_C1_CoxUV <- norm_C1_CoxUV[order(norm_C1_CoxUV$predRisk), ]
norm_C1_CoxUV$Order <- 1:nrow(norm_C1_CoxUV)
ggplot(norm_C1_CoxUV, aes(x = Order, y = predRisk, color = EFS)) +
  geom_point(size = 2) +
  scale_color_manual(values = c("relapse" = "#EE5C42", "noRelapse" = "#00EE76")) +
  labs(x = "Ordered by Risk-score", y = "Risk-score", title = "DC Risk-score ALASSO") +
  theme_minimal()
#KM
quartiles <- quantile(norm_C1_CoxUV$predRisk, probs = c(0, 0.7, 0.9, 1))
intervalos <- cut(norm_C1_CoxUV$predRisk, breaks = quartiles, labels = c("Low-risk", "Intermediate-risk", "High-risk"), include.lowest = T)
norm_C1_CoxUV$predGr = as.factor(intervalos)
norm_C1_CoxUV$eventTime = as.numeric(as.character(norm_C1_CoxUV$eventTime))
norm_C1_CoxUV$EFS[norm_C1_CoxUV$EFS == "relapse"] <- "1"
norm_C1_CoxUV$EFS[norm_C1_CoxUV$EFS == "noRelapse"] <- "0"
norm_C1_CoxUV$EFS = as.numeric(as.character(norm_C1_CoxUV$EFS))
fit <- survfit(Surv(eventTime, EFS) ~ predGr, data = norm_C1_CoxUV)
(log_rank_test_C1 <- survdiff(Surv(eventTime, EFS) ~ predGr, data = norm_C1_CoxUV))
p1 = ggsurvplot(fit,
           pval = T,
           conf.int = F,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Predicted risk groups in C1",
           palette = c("seagreen3", "cadetblue3", "firebrick2"),
           size.ci = 1,
           legend.title = "")

p1$plot <- p1$plot + theme(
  plot.title = element_text(size = 13, face = "bold", hjust = 0.4), # Cambia el tamaño del título             # Cambia el tamaño del título de la leyenda
  legend.text = element_text(size = 8),              # Cambia el tamaño del texto de la leyenda
  axis.title.x = element_text(size = 10),             # Cambia el tamaño del título del eje X
  axis.title.y = element_text(size = 10),             # Cambia el tamaño del título del eje Y
  axis.text.x = element_text(size = 9),              # Cambia el tamaño de los textos del eje X
  axis.text.y = element_text(size = 9)               # Cambia el tamaño de los textos del eje Y
)

# Mostrar el gráfico
print(p1)
#Se cumple la proporcionalidad? curvas log(-log), si se cruzan violación de la proporcionalidad
plot(fit, fun = "cloglog")
# Comparación entre grupos
(pairwise_results <- pairwise_survdiff(Surv(eventTime, EFS) ~ predGr, data = norm_C1_CoxUV, p.adjust.method = "BH"))

norm_C2_CoxUV = data.frame(norm1_C2)
colData_C2_surv = colData_C2
colData_C2_surv$eventTime = as.numeric(as.character(colData_C2_surv$eventTime))
norm_C2_CoxUV = cbind(colData_C2_surv, t(norm_C2_CoxUV))
#Predictions
norm_C2_CoxUV$predRisk = predict(surviBALL, newdata = norm_C2_CoxUV)
#Risk plot
norm_C2_CoxUV <- norm_C2_CoxUV[order(norm_C2_CoxUV$predRisk), ]
norm_C2_CoxUV$Order <- 1:nrow(norm_C2_CoxUV)
ggplot(norm_C2_CoxUV, aes(x = Order, y = predRisk, color = EFS)) +
  geom_point(size = 2) +
  scale_color_manual(values = c("relapse" = "#EE5C42", "noRelapse" = "#00EE76")) +
  labs(x = "Ordered by Risk-score", y = "Risk-score", title = "C2 Risk-score ALASSO") +
  theme_minimal()
#KM
quartiles <- quantile(norm_C2_CoxUV$predRisk, probs = c(0, 0.7, 0.9, 1))
intervalos <- cut(norm_C2_CoxUV$predRisk, breaks = quartiles, labels = c("Low-risk", "Intermediate-risk", "High-risk"), include.lowest = T)
norm_C2_CoxUV$predGr = as.factor(intervalos)
norm_C2_CoxUV$eventTime = as.numeric(as.character(norm_C2_CoxUV$eventTime))
norm_C2_CoxUV$EFS[norm_C2_CoxUV$EFS == "relapse"] <- "1"
norm_C2_CoxUV$EFS[norm_C2_CoxUV$EFS == "noRelapse"] <- "0"
norm_C2_CoxUV$EFS = as.numeric(as.character(norm_C2_CoxUV$EFS))
fit <- survfit(Surv(eventTime, EFS) ~ predGr, data = norm_C2_CoxUV)
(log_rank_test_C2 <- survdiff(Surv(eventTime, EFS) ~ predGr, data = norm_C2_CoxUV))
p2 = ggsurvplot(fit,
           pval = T,
           conf.int = F,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Predicted risk groups in C2",
           palette = c("seagreen3", "cadetblue3", "firebrick2"),
           size.ci = 1,
           legend.title = "")

p2$plot <- p2$plot + theme(
  plot.title = element_text(size = 13, face = "bold", hjust = 0.4),
  legend.text = element_text(size = 8),
  axis.title.x = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  axis.text.x = element_text(size = 9),
  axis.text.y = element_text(size = 9))

# Mostrar el gráfico
print(p2)
plot(fit, fun = "cloglog")
# Comparación entre grupos
(pairwise_results <- pairwise_survdiff(Surv(eventTime, EFS) ~ predGr, data = norm_C2_CoxUV, p.adjust.method = "BH"))


norm_CoxUV = data.frame(norm1)
colData_surv = colData
colData_surv$eventTime = as.numeric(as.character(colData_surv$eventTime))
colData_surv$EFSb <- ifelse(colData_surv$EFS == "relapse", 1, 
                               ifelse(colData_surv$EFS == "noRelapse", 0, colData_surv$EFS))
colData_surv$EFSb = as.numeric(as.character(colData_surv$EFSb))
norm_CoxUV = cbind(colData_surv, t(norm_CoxUV))
norm_CoxUV$predRisk = predict(surviBALL, newdata = norm_CoxUV)
norm_CoxUV <- norm_CoxUV[order(norm_CoxUV$predRisk), ]
norm_CoxUV$Order <- 1:nrow(norm_CoxUV)
ggplot(norm_CoxUV, aes(x = Order, y = predRisk, color = EFS, shape = cohort)) +
  geom_point(size = 2) +
  scale_color_manual(values = c("relapse" = "#EE5C42", "noRelapse" = "#00EE76")) +
  labs(x = "Ordered by Risk-score", y = "Risk-score", title = "Risk-score ALASSO newdata all") +
  theme_minimal()

#KM
quartiles <- quantile(norm_CoxUV$predRisk, probs = c(0, 0.7, 0.9, 1))
intervalos <- cut(norm_CoxUV$predRisk, breaks = quartiles, labels = c("Low-risk", "Intermediate-risk", "High-risk"), include.lowest = T)
norm_CoxUV$predGr = as.factor(intervalos)
norm_CoxUV$eventTime = as.numeric(as.character(norm_CoxUV$eventTime))

fit <- survfit(Surv(eventTime, EFSb) ~ predGr, data = norm_CoxUV)
(log_rank_test_C12 <- survdiff(Surv(eventTime, EFSb) ~ predGr, data = norm_CoxUV))
p3 = ggsurvplot(fit,
           pval = T,
           conf.int = F,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Predicted risk groups in C1 + C2",
           palette = c("seagreen3", "cadetblue3", "firebrick2"),
           size.ci = 1,
           legend.title = "")

p3$plot <- p3$plot + theme(
  plot.title = element_text(size = 13, face = "bold", hjust = 0.4),
  legend.text = element_text(size = 8),
  axis.title.x = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  axis.text.x = element_text(size = 9),
  axis.text.y = element_text(size = 9))

# Mostrar el gráfico
print(p3)
plot(fit, fun = "cloglog")

p4 = ggsurvplot(fit,
           pval = T,
           conf.int = T,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Predicted risk groups in C1 + C2",
           palette = c("seagreen3", "cadetblue3", "firebrick2"),
           size.ci = 1.3,
           legend.title = "")

p4$plot <- p4$plot + theme(
  plot.title = element_text(size = 13, face = "bold", hjust = 0.4),
  legend.text = element_text(size = 8),
  axis.title.x = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  axis.text.x = element_text(size = 9),
  axis.text.y = element_text(size = 9))

# Mostrar el gráfico
print(p4)
# Comparación entre grupos
(pairwise_results <- pairwise_survdiff(Surv(eventTime, EFSb) ~ predGr, data = norm_CoxUV, p.adjust.method = "BH"))
```

## riskScore box-plots

```{r predRisk boxplots, message = FALSE, warning = FALSE}
bp = cbind(norm_CoxUV[,1:14], norm_CoxUV[,75829:75831])
bp <- bp %>%
  mutate(Cohort_EFSb = paste(cohort, EFSb, sep = "_"))

# Realizamos el test t con ajuste Bonferroni y posiciones para la significancia
stats <- bp %>%
    t_test(data = ., predRisk ~ cohort) %>%
    adjust_pvalue(method = "bonferroni") %>%
    add_significance("p.adj") %>%
    add_xy_position(x = "cohort")

ggplot(bp, aes(x = cohort, y = predRisk)) +
    geom_boxplot(aes(fill = as.factor(cohort)), alpha = 0.6) + # Caja
    geom_jitter(aes(color = as.factor(predGr)), width = 0.2, size = 2, alpha = 0.7) + # Puntos
    theme_bw() +
    ylab("Predicted risk value") +
    xlab("Cohort") +
    ggtitle("Boxplot with predicted risk values per cohort") +
    scale_fill_manual(values = c("#4889A4", "#C26060"), name = "Cohort") + # Colores de cajas
    scale_color_manual(values = c("seagreen3", "cadetblue3", "firebrick2"), name = "PredGr") +
    stat_pvalue_manual(stats, label = "p.adj.signif", tip.length = 0.01)

# Realizamos el test t con ajuste Bonferroni y posiciones para la significancia entre grupos de riesgo
stats <- bp %>%
    t_test(data = ., predRisk ~ predGr) %>%  # Cambiamos cohort por predGr
    adjust_pvalue(method = "bonferroni") %>%
    add_significance("p.adj") %>%
    add_xy_position(x = "predGr")

ggplot(bp, aes(x = as.factor(predGr), y = predRisk)) +
    geom_boxplot(aes(fill = as.factor(predGr)), alpha = 0.6) +
    geom_jitter(aes(shape = as.factor(Cohort_EFSb), size = as.factor(Cohort_EFSb)), 
    width = 0.2, alpha = 0.7) +
    theme_bw() +
    ylab("Predicted risk value") +
    xlab("Risk Group") +
    ggtitle("Boxplot of predicted risk values by risk groups") +
    scale_fill_manual(values = c("seagreen3", "cadetblue3", "firebrick2"), name = "Risk Group") +
    scale_shape_manual(values = c(1, 19, 2, 17), name = "Cohort") +
    scale_size_manual(values = c(2.3, 3, 1.8, 2.7), name = "Relapse Status") +
    stat_pvalue_manual(stats, label = "p.adj.signif", tip.length = 0.01)
```

# Gene biotype comparison

```{r Gene biotype comparison plot min. expression}
step <- c(rep("lncRNAKB full" , 4) , rep("C1 min. expr." , 4) , rep("C2 min. expr." , 4) , rep("Overlapping genes" , 4) , rep("ALASSO candidates" , 4))
Biotype <- rep(c("Antisense RNA", "lncRNA", "Miscellaneous RNA", "Protein coding"), 5)
Percentage <- c(2.2, 75.3, 1.3, 21.2, 2.01,	75.39, 1.24,	21.27, 2.41, 70.58, 1.46, 25.54, 0, 89.6, 2.1, 8.3, 0, 100, 0, 0)
data <- data.frame(step,Biotype,Percentage)
positions = c("lncRNAKB full", "C1 min. expr.", "C2 min. expr.", "Overlapping genes", "ALASSO candidates")
 
ggplot(data, aes(fill = Biotype, y = Percentage, x = step)) + 
    geom_bar(position = "fill", stat = "identity") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 25)) +
    scale_x_discrete(limits = positions) +
    labs(x = "", y = "Percentage") +
    ggtitle("Biotype comparison between different steps of the analysis") +
    scale_y_continuous(labels = scales::percent_format())
```

## CLINICAL VARIABLES C1 + C2, predVal

```{r Clinical risk comparison new C1}
set.seed(12345)

# predRisk alone
cox_covar = coxph(Surv(eventTime, EFSb) ~ predRisk, data = norm_CoxUV, x = T)
summary(cox_covar)

# Age
cox_covar_age = coxph(Surv(eventTime, EFSb) ~ ageDiagnosis, data = norm_CoxUV, x = T)
summary(cox_covar_age)

# Age + predRisk
cox_covar_age = coxph(Surv(eventTime, EFSb) ~ predRisk + ageDiagnosis, data = norm_CoxUV, x = T)
summary(cox_covar_age)

# Sex
cox_covar_sex = coxph(Surv(eventTime, EFSb) ~ sex, data = norm_CoxUV, x = T)
summary(cox_covar_sex)

# Sex + predRisk
cox_covar_sex = coxph(Surv(eventTime, EFSb) ~ predRisk + sex, data = norm_CoxUV, x = T)
summary(cox_covar_sex)

# subtype
cox_covar_subtype = coxph(Surv(eventTime, EFSb) ~ predictedSubtype, data = norm_CoxUV, x = T)
summary(cox_covar_subtype)

# subtype + predRisk
cox_covar_subtype = coxph(Surv(eventTime, EFSb) ~ predRisk + predictedSubtype, data = norm_CoxUV, x = T)
summary(cox_covar_subtype)

# All variables
cox_covar_all = coxph(Surv(eventTime, EFSb) ~ predictedSubtype + sex + ageDiagnosis, data = norm_CoxUV, x = T)
summary(cox_covar_all)

# All variables + predRisk
cox_covar_all = coxph(Surv(eventTime, EFSb) ~ predRisk + predictedSubtype + sex + ageDiagnosis, data = norm_CoxUV, x = T)
summary(cox_covar_all)
```

## TARGET cohort validation

```{r TARGET cohort validation, message = F, warning = F}
#Inputs and prepare metaData
countData_TARGET = data.frame(read_delim("TARGET_surviBALL/lncRNAKB_counts.txt"), row.names = 1)
metaData_TARGET <- data.frame(read_excel("Z:/ALL/Survival/TARGET/Metadata_full.xlsx", sheet = "BALL_surviBALL"), row.names = 1)
countData_TARGET <- countData_TARGET[,rownames(metaData_TARGET)]
countData_TARGET <- merge(countData_TARGET, lncRNAKB_annot, by = c(0))
countData_TARGET = subset(countData_TARGET, !grepl("_", chr)) #From 99695 to 95776 genes
countData_TARGET <- data.frame(countData_TARGET[, -c(179:184)], row.names = 1)
countData_TARGET = countData_TARGET[rowSums(countData_TARGET >= 1) >= 3,] #From 95776 to 93711 genes
print(identical(rownames(metaData_TARGET), colnames(countData_TARGET)))

#DESeq
dds_T <- DESeqDataSetFromMatrix(countData = countData_TARGET, colData = metaData_TARGET, design = ~1)
dds_T <- DESeq(dds_T)
norm_T = data.frame(counts(dds_T, normalized = T))
scaled_T <- data.frame(scale(norm_T))

# surviBALL
metaData_surv = metaData_TARGET[,c(3,5:12,19,20,24,25)]
metaData_surv$EFS[metaData_surv$First.Event != "None"] <- "1" 
metaData_surv$EFS[metaData_surv$First.Event == "None"] <- "0" 
metaData_surv$OS[metaData_surv$Vital.Status == "Dead"] <- "1" 
metaData_surv$OS[metaData_surv$Vital.Status == "Alive"] <- "0"
#write.table(metaData_surv, "metaData_surv.txt", sep = "\t")
metaData_surv <- read_excel("TARGET_surviBALL/metaData_surv.xlsx")
norm_surv = cbind(metaData_surv, t(scaled_T))

#Predictions
#surviBALL = readRDS("C:/Users/834733/Documents/EHU/Lab/ALL/Survival/Paper_bioinfo/surviBALL.rda")
norm_surv$predRisk = predict(surviBALL, newdata = norm_surv)
#Risk plot
norm_surv <- norm_surv[order(norm_surv$predRisk), ]
norm_surv$Order <- 1:nrow(norm_surv)
ggplot(norm_surv, aes(x = Order, y = predRisk, color = as.character(EFS_5))) +
  geom_point(size = 2) +
  scale_color_manual(values = c("1" = "#EE5C42", "0" = "#00EE76")) +
  labs(x = "Ordered by Risk-score", y = "Risk-score", title = "TARGET surviBALL") +
  theme_minimal()
#KM
quartiles <- quantile(norm_surv$predRisk, probs = c(0, 0.7, 0.9, 1))
intervalos <- cut(norm_surv$predRisk, breaks = quartiles, labels = c("Low-risk", "Intermediate-risk", "High-risk"), include.lowest = T)
norm_surv$predGr = as.factor(intervalos)
norm_surv$EFS_Time = as.numeric(as.character(norm_surv$EFS_Time))
norm_surv$EFS = as.numeric(as.character(norm_surv$EFS))
fit <- survfit(Surv(EFS_Time_5_Months, EFS_5) ~ predGr, data = norm_surv)
summary(fit)
(log_rank_test <- survdiff(Surv(EFS_Time_5_Months, EFS_5) ~ predGr, data = norm_surv))
KM = ggsurvplot(fit,
                pval = T,
                conf.int = F,
                risk.table = F,
                surv.median.line = "hv",
                xlab = "Time (days)",
                title = "surviBALL predicted risk groups in TARGET",
                palette = c("seagreen3", "cadetblue3", "firebrick2"),
                size.ci = 1,
                legend.title = "")

KM$plot <- KM$plot + theme(plot.title = element_text(size = 13, face = "bold", hjust = 0.4),
  legend.text = element_text(size = 8),
  axis.title.x = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  axis.text.x = element_text(size = 9),
  axis.text.y = element_text(size = 9))

# Mostrar el gráfico
print(KM)
# Comparación entre grupos
(pairwise_results <- pairwise_survdiff(Surv(EFS_Time_5_Months, EFS_5) ~ predGr, data = norm_surv, p.adjust.method = "BH"))
```

# qPCR validation

```{r qPCR validation C1}
setwd("C://users/834733/Documents/EHU/Lab/ALL/Survival/Paper_bioinfo/qPCRs")

RQ <- read_excel("RQ_qPCRs.xlsx", sheet = "log2RQ")
RQ <- data.frame(RQ, row.names = 1)
set.seed(12345)
cox_qPCR = coxph(Surv(eventTime, EFS_Status) ~ lnckb.32044 + lnckb.61426 + lnckb.66409 + lnckb.83321 + lnckb.8576, data = RQ, x = T)
summary(cox_qPCR)
cox.zph(cox_qPCR)
ggforest(cox_qPCR)

# Time-dependent ROC C1
RQ$lpALASSO <- predict(cox_qPCR, newdata = RQ, type = "lp")
nobs <- NROW(RQ)
timeCut <- 60
Staltscore4 <- NULL
ROC_C1 <- survivalROC.C(Stime = RQ$eventTime,
                        status = RQ$EFS_Status,
                        marker = RQ$lpALASSO,
                        predict.time = timeCut,
                        span = 0.25*nobs^(-0.20))
plot(ROC_C1$FP, ROC_C1$TP, type = "l",
     xlim = c(0,1), ylim = c(0,1),
     xlab = paste( "FP \n AUC =", round(ROC_C1$AUC,3)),
     ylab = "TP", main = "Time-dependent ROC curve qPCR model")
abline(0,1)

RQ$pred_qPCR = predict(cox_qPCR, newdata = RQ)


#Risk plot
RQ <- RQ[order(RQ$pred_qPCR), ]
RQ$Order <- 1:nrow(RQ)
ggplot(RQ, aes(x = Order, y = pred_qPCR, color = EFS)) +
  geom_point(size = 2) +
  scale_color_manual(values = c("relapse" = "#EE5C42", "noRelapse" = "#00EE76")) +
  labs(x = "Ordered by Risk-score", y = "Risk-score", title = "qPCR C1 Risk-score") +
  theme_minimal()

#KM
quartiles <- quantile(RQ$pred_qPCR, probs = c(0, 0.7, 0.9, 1))
intervalos <- cut(RQ$pred_qPCR, breaks = quartiles, labels = c("Low-risk", "Intermediate-risk", "High-risk"), include.lowest = TRUE)
RQ$predGr = as.factor(intervalos)
RQ$eventTime = as.numeric(as.character(RQ$eventTime))
RQ$EFS[RQ$EFS == "relapse"] <- "1"
RQ$EFS[RQ$EFS == "noRelapse"] <- "0"
RQ$EFS = as.numeric(as.character(RQ$EFS))
fit <- survfit(Surv(eventTime, EFS) ~ predGr, data = RQ)
(log_rank_test_C1_qPCR <- survdiff(Surv(eventTime, EFS) ~ predGr, data = RQ))
p1 = ggsurvplot(fit,
                pval = T,
                conf.int = F,
                risk.table = F,
                surv.median.line = "hv",
                xlab = "Time (months)",
                title = "Predicted risk groups in C1 (qPCR validation)",
                palette = c("seagreen3", "cadetblue3", "firebrick2"),
                size.ci = 1.3,
                legend.title = "")

p1$plot <- p1$plot + theme(
  plot.title = element_text(size = 13, face = "bold", hjust = 0.4),
  legend.text = element_text(size = 8),
  axis.title.x = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  axis.text.x = element_text(size = 9),
  axis.text.y = element_text(size = 9))

# Mostrar el gráfico
print(p1)
(pairwise_results <- pairwise_survdiff(Surv(eventTime, EFS) ~ predGr, data = RQ, p.adjust.method = "BH"))

# Correlations between RNA-seq and qPCR predicted values
predVal <- data.frame(merge(RQ, norm_C1_CoxUV, by = c(0)), row.names = 1)
result <- cor.test(predVal$pred_qPCR, predVal$predRisk, method = "spearman")

# To get the r-value and p-val
(r_value <- result$estimate)
(p_value <- result$p.value)
```

# Supplementary survival figures

```{r protocol..., message = F, warning = F}
fit <- survfit(Surv(eventTime, EFSb) ~ cohort, data = norm_CoxUV)
(fitp <- survdiff(Surv(eventTime, EFSb) ~ cohort, data = norm_CoxUV))
ggsurvplot(fit,
           pval = TRUE,
           conf.int = F,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Kaplan-Meier curve comparing C1 vs. C2")
fit <- survfit(Surv(eventTime, EFS) ~ protocol, data = norm_C2_CoxUV)
(fitp <- survdiff(Surv(eventTime, EFS) ~ protocol, data = norm_C2_CoxUV))
ggsurvplot(fit,
           pval = TRUE,
           conf.int = F,
           surv.median.line = "hv",
           xlab = "Time (months)",
           title = "Kaplan-Meier curve comparing different protocols in C2")
```

# Correlations

```{r C1+C2 cormat, message = F, warning = F}
corInput <- subset(lncRNAKB_annot, lncRNAKB_annot$Biotype == "protein_coding")
corInput2 <- lncRNAKB_annot[cox_C1_CoxUV_ALASSO_vars,]
corInput <- rbind(corInput, corInput2)
corInput_C12 <- data.frame(merge(norm1, corInput, by = c(0)), row.names = 1)
corInput_C12 <- data.frame(corInput_C12[, c(1:122)])
cormat <- rcorr(as.matrix(t(corInput_C12)), type = c("pearson"))
  r <- cormat$r
  rr <- round(r, 3)
  p <- cormat$P
  flattenCorrMatrix <- function(rr, p) {
    ut <- upper.tri(rr)
    data.frame(
      GeneID_1 = rownames(rr)[row(rr)[ut]],
      GeneID_2 = rownames(rr)[col(rr)[ut]],
      cor_val  =(rr)[ut],
      p_val = p[ut]
    )
  }
flatten_cormat_C12 <- flattenCorrMatrix(rr, p)
flatten_cormat_C12 <- subset(flatten_cormat_C12, p_val<=0.01) #2276
flatten_cormat_C12 <- subset(flatten_cormat_C12, abs(cor_val)>=0.5) #1733
flatten_cormat_C12 <- merge(flatten_cormat_C12, Annotation_lncRNAKB, by=c(1))
flatten_cormat_C12 <- flatten_cormat_C12[, c(2,1,3,4,5,6,7,8,9,10)]
flatten_cormat_C12 <- merge(flatten_cormat_C12, Annotation_lncRNAKB, by=c(1))
flatten_cormat_C12 <- flatten_cormat_C12[, c(2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16)]
flatten_cormat_C12_Biotype <- subset(flatten_cormat_C12, Biotype.x!=Biotype.y) #145
write.table(flatten_cormat_C12_Biotype, "results/flatten_cormat_C12_Biotype.txt", sep = "\t", row.names = F)
```

## Bubbles

```{r bubbles, message = F, warning = F}
Bubbles = read_excel("inputs/Bubbles_all.xlsx", sheet = "All")
Bubbles = Bubbles %>% mutate(`-log(q-value)` = -log(`q-value`, base = 10))

ggplot(Bubbles, aes(x = order, y = `-log(q-value)`)) + 
  geom_point(aes(color = lncRNA, size = size), alpha = 0.3) +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "black") +
  theme_minimal() +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
  labs(title = "ORA result as bubbles plot",
       caption = "Source: consensusPath (http://cpdb.molgen.mpg.de/)",
       x = "lncRNAs and pathways",
       y = "-log(q-value)",
       color = "lncRNA in surviBALL",
       size = "Genes in pathway")
```

